QTR Sensor Rover Project Info:
-----------------------------

	1. Calibrated Constant for Sensors: 61

	2.

	[7] [6] [5] [4] [3] [2] [1] [0]

		-Straight will check against [6] and [5] for left
				  will check against [2] and [1] for right

		-Turns, Intersections, Tees will check against [7] and [7] for left
									will check against [1] and [0] for right

		-Dead End will check against [4]


		-End Zone will check [7] [4] [0] 


Programming AVR:
---------------

	1. avrdude -c usbtiny -p atmega32u4 -U flash:w:<File_name>

AVR C:
-----

	1. //Turn on LEDs 7 and 6 without affecting the state of LEDs 5 through  0


		#define MASK  0xC0 //C0 hex is 11000000 binary

		LEDS = LEDS | MASK;  

	2. 

Project Code Ideas:
------------------

	1. while(1){
		if(){

		}
		else if(){

		}
		else if(){
			
		}
		else if(){
			
		}
		else{
			//go forward
		}
	}

	2.
		When a special function register refers to an input to the processor (such as SWITCHES), we often need to know the value of a subset of the bits of the register.  For example, we might want to know the the bit on SWITCHES[3] or the 4-bit value on SWITCHES[3:0].  Here, again, we can use masking to isolate the bits of interest and, optionally, shifting to move the bits to another position.  For example, to determine whether bits 5 and 6 contain 0 and 1, respectively, we could

		//Do something when SWITCHES[6:5]=01

		#define MASK  0x60 //60 hex is 01100000 binary

		if( SWITCHES & MASK == 0x20 )  //20 hex is 00100000 binary
		{
		        //insert code here
		}

		or, we could convert a set of bits to an integer, as in  

		//Get 4-bit integer value N on SWITCHES[5:2] 

		#define N_MASK  0x3C //3C hex is 00111100 binary

		unsigned char N; 

		N = (SWITCHES & N_MASK) >> 2;

		For each of the following operations, provide a sequence of C-language statements to implement the operation.

		Increment COUNT if SWITCHES[5] is low
		Clear COUNT if SWITCHES[5:4] is not equal to '11'
		The input SWITCHES represents two, 4-bit inputs (SWITCHES[7:4] and SWITCHES[3:0]).  Compute the sum of the two inputs.


	3. 
			Often, the bit positions of input bits or output bits within a port are defined in header files using #define statements, such as in the example below.  This is done to make the code more easy to maintain if the hardware configuration is later changed.  Masks can be easily generated from these bit positions using shift operations, as shown.

		//Turn on LEDs 7 and 6 without affecting the state of LEDs 5 through  0

		#define CONTROL_PORT  PORTF //The port containing the output bits
		#define CONTROL_A     3     //control 'A' is at bit 3 of the port
		#define CONTROL_B     5     //control 'B' is at bit 5 of the port

		//SET A (to '1')
		CONTROL_PORT |= (1<<CONTROL_A);

		//CLEAR B (to '0')
		CONTROL_PORT &= ~(1<<CONTROL_B);

		//SET BOTH A and B
		CONTROL_PORT |= ( (1<<CONTROL_A) | (1 << CONTROL_B) );

		For each of the following operations, provide a single C-language statement to implement the operation.  Assume all constants are defined elsewhere.

		Set bits LEFT_A and LEFT_B in LEFT_PORT_OUT
		Clear bits ENCODER_A and ENCODER_B in LEFT_PORT_OUT